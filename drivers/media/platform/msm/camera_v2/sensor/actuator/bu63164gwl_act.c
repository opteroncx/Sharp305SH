/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#define pr_fmt(fmt) "%s:%d " fmt, __func__, __LINE__

#include <linux/module.h>
#include "msm_sd.h"
#include "msm_actuator.h"
#include "msm_cci.h"
#include <sharp/sh_boot_manager.h>

DEFINE_MSM_MUTEX(bu63164gwl_act_mutex);

//#define MSM_ACUTUATOR_DEBUG
#undef CDBG
#ifdef MSM_ACUTUATOR_DEBUG
#define CDBG(fmt, args...) pr_err(fmt, ##args)
#else
#define CDBG(fmt, args...) pr_debug(fmt, ##args)
#endif

#undef CDBG_DEB
//#define CDBG_DEB(fmt, args...) pr_err(fmt, ##args)
//#define CDBG_DEB(fmt, args...) pr_debug(fmt, ##args)
#define CDBG_DEB(fmt, args...)

//#define ACTUATOR_DEBUG

#define BU63164GWL_OIS_CMD_PER	0x82
#define BU63164GWL_OIS_CMD_MEM	0x84
#define BU63164GWL_OIS_CMD_SPE	0x8C

struct bu63164gwl_ois_reg_conf {
	uint8_t type;
	uint8_t addr;
	uint16_t data;
};

static struct bu63164gwl_ois_reg_conf ois_init_setting1[] = {
  /* AF par1 */
  {BU63164GWL_OIS_CMD_MEM, 0xD4, 0x55C3},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xD5, 0x6000},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xD6, 0x7FFF},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xD7, 0x7FFF},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xD8, 0x7FFF},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xD9, 0x7FFF},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xDA, 0x7FFF},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xDB, 0x7FFF},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xDC, 0x7FFF},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xDD, 0x7FFF},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xDE, 0x7FFF},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xDF, 0x7FFF},     /*                          */
  /* SystemCLK par1 */
  {BU63164GWL_OIS_CMD_PER, 0x62, 0x018A},     /*                          */
  {BU63164GWL_OIS_CMD_PER, 0x63, 0x0437},     /*                          */
  {BU63164GWL_OIS_CMD_PER, 0x64, 0x4060},     /*                          */
  {BU63164GWL_OIS_CMD_PER, 0x60, 0x3011},     /*                          */
  {BU63164GWL_OIS_CMD_PER, 0x65, 0x0080},     /*                          */
  {BU63164GWL_OIS_CMD_PER, 0x61, 0x8002},     /*                          */
  {BU63164GWL_OIS_CMD_PER, 0x61, 0x8003},     /*                          */
  {BU63164GWL_OIS_CMD_PER, 0x61, 0x8809},     /*                          */
};

static struct bu63164gwl_ois_reg_conf ois_init_setting2[] = {
  /* SystemCLK par2 */
  {BU63164GWL_OIS_CMD_PER, 0x05, 0x000C},     /*                          */
  {BU63164GWL_OIS_CMD_PER, 0x05, 0x000D},     /*                          */
  /* Special command */
  {BU63164GWL_OIS_CMD_SPE, 0x01, 0x0000},     /*                          */
  /* AF par2 */
  {BU63164GWL_OIS_CMD_MEM, 0xD0, 0x7FDF},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xD1, 0x6000},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xD2, 0x199A},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0xD3, 0x2B85},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0x79, 0x1C1B},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0x7A, 0x8000},     /*                          */
  {BU63164GWL_OIS_CMD_MEM, 0x7B, 0x7FFF},     /*                          */
};

static uint8_t bu63164gwl_act_init_fw_settings[] = {
	0x80, 0x00, 0x22, 0x60, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0x73, 0x84, 0x08, 0x71,
	0x84, 0x00, 0x00, 0x11, 0x00, 0x03, 0x00, 0x10, 0x73, 0x84, 0x00, 0x00, 0x08, 0x40, 0x73, 0xA0,
	0x00, 0x01, 0x11, 0x8F, 0x02, 0x07, 0x20, 0x06, 0x07, 0x50, 0x00, 0x08, 0xFF, 0xFF, 0x11, 0x40,
	0x87, 0xA0, 0x10, 0x71, 0x84, 0x00, 0x00, 0x08, 0x40, 0x71, 0xA0, 0x00, 0x01, 0x11, 0x8F, 0x02,
	0x07, 0x20, 0x06, 0x07, 0x50, 0x00, 0x08, 0xFF, 0xFF, 0x11, 0x40, 0x07, 0xA0, 0x40, 0x7F, 0xA0,
	0x00, 0x03, 0x00, 0x90, 0x17, 0x84, 0x20, 0x0F, 0x08, 0x80, 0x47, 0xA0, 0x8D, 0x04, 0x07, 0x00,
	0x00, 0x11, 0x30, 0x03, 0x07, 0x80, 0x41, 0x90, 0x50, 0x00, 0x08, 0x40, 0xFC, 0x90, 0x88, 0x2F,
	0x84, 0x00, 0x00, 0x11, 0x30, 0x02, 0x07, 0x40, 0xFF, 0x90, 0x50, 0x00, 0x08, 0x40, 0xFD, 0x90,
	0x40, 0x7F, 0xA0, 0x10, 0xFF, 0x84, 0x20, 0x2C, 0x08, 0x7F, 0xFF, 0x11, 0x20, 0x0D, 0x08, 0x80,
	0x0F, 0x90, 0x80, 0x26, 0xA0, 0x90, 0x2E, 0x84, 0x00, 0x10, 0x08, 0x90, 0x26, 0x84, 0x00, 0x10,
	0x08, 0x80, 0x1F, 0xA0, 0x20, 0x2E, 0x08, 0x40, 0xED, 0x90, 0x20, 0x0F, 0x08, 0x80, 0x0E, 0x90,
	0x00, 0x00, 0x21, 0x30, 0x02, 0x07, 0x40, 0xEB, 0xA0, 0x50, 0x00, 0x08, 0x40, 0xFE, 0x90, 0x40,
	0x7F, 0xA0, 0x04, 0xEB, 0x84, 0x10, 0x00, 0x20, 0x20, 0x0F, 0x08, 0x80, 0x00, 0x21, 0x60, 0x04,
	0x07, 0x40, 0xFF, 0xA0, 0x10, 0x00, 0x08, 0x40, 0xEA, 0x90, 0x10, 0x00, 0x20, 0x20, 0x0F, 0x08,
	0x80, 0x00, 0x11, 0x00, 0x0B, 0x07, 0x08, 0x00, 0x20, 0x60, 0x0D, 0x07, 0x10, 0x00, 0x08, 0x40,
	0xEA, 0x90, 0x8F, 0x06, 0x07, 0x04, 0xFF, 0x84, 0x20, 0x09, 0x60, 0x10, 0xFC, 0x84, 0x08, 0xFD,
	0x84, 0x04, 0xFE, 0x84, 0x00, 0x03, 0x00, 0x00, 0x10, 0x08, 0x80, 0x37, 0xA0, 0x90, 0x69, 0x84,
	0x00, 0x10, 0x08, 0x80, 0x69, 0xA0, 0x20, 0x1A, 0x08, 0x40, 0x64, 0xA0, 0x10, 0x10, 0x08, 0x80,
	0x4F, 0xA0, 0x20, 0x1D, 0x08, 0x40, 0x5F, 0xA0, 0x20, 0x1E, 0x08, 0x40, 0x5D, 0xA0, 0x10, 0x00,
	0x08, 0x80, 0x68, 0x90, 0x40, 0xFE, 0xA0, 0x20, 0x0E, 0x07, 0x50, 0x00, 0x08, 0x40, 0x7F, 0xA0,
	0x04, 0xFE, 0x84, 0x00, 0x04, 0x00, 0x10, 0xF0, 0x44, 0x50, 0x00, 0x08, 0x00, 0x7F, 0x11, 0x20,
	0xF0, 0x60, 0x04, 0x5C, 0x84, 0x04, 0x61, 0x84, 0x04, 0x57, 0x84, 0x00, 0x00, 0x21, 0x04, 0x74,
	0x84, 0x00, 0x40, 0x21, 0x00, 0x0B, 0x07, 0x04, 0x74, 0x84, 0x00, 0x00, 0x21, 0x10, 0x57, 0x84,
	0x30, 0x20, 0x08, 0x00, 0x04, 0x11, 0x50, 0x00, 0x08, 0x03, 0xFF, 0x11, 0x20, 0xFA, 0x60, 0x10,
	0xF0, 0x44, 0x50, 0x20, 0x08, 0x00, 0x7F, 0x11, 0x60, 0x20, 0x08, 0x40, 0x00, 0x08, 0x00, 0x08,
	0x11, 0x30, 0x1A, 0x07, 0x50, 0x00, 0x08, 0x07, 0x00, 0x11, 0x9F, 0x1D, 0x07, 0x8B, 0x1E, 0x07,
	0x9C, 0x15, 0x07, 0x20, 0xF8, 0x60, 0x10, 0x28, 0x44, 0x60, 0x00, 0x08, 0x01, 0x00, 0x11, 0x20,
	0x28, 0x60, 0x87, 0x1B, 0x07, 0x40, 0xF7, 0xA0, 0x81, 0x27, 0x07, 0x20, 0x48, 0x60, 0x10, 0x0A,
	0x44, 0x10, 0xF4, 0x84, 0x3B, 0x76, 0x00, 0xE0, 0x14, 0x43, 0x08, 0x00, 0x20, 0x00, 0x06, 0x07,
	0x89, 0x02, 0x07, 0x40, 0xAE, 0x90, 0x81, 0x04, 0x07, 0x40, 0x2E, 0x90, 0x40, 0x7F, 0xA0, 0x10,
	0x2E, 0x44, 0x20, 0x2E, 0x08, 0x7F, 0xFF, 0x11, 0x10, 0x20, 0x08, 0x40, 0x00, 0x11, 0x92, 0x05,
	0x07, 0x20, 0x72, 0x60, 0x00, 0x00, 0x08, 0x40, 0x67, 0xA0, 0x00, 0x00, 0x11, 0x84, 0x02, 0x07,
	0x20, 0xF0, 0x60, 0x9F, 0x03, 0x07, 0x40, 0x7E, 0xA0, 0x40, 0x65, 0x90, 0x10, 0x62, 0x84, 0x10,
	0x10, 0x08, 0x40, 0x61, 0xA0, 0x20, 0x1D, 0x08, 0x40, 0x5F, 0xA0, 0x20, 0x1E, 0x08, 0x40, 0x5D,
	0xA0, 0x10, 0x00, 0x08, 0x40, 0x5E, 0x90, 0x20, 0x30, 0x60, 0x10, 0xCF, 0x84, 0x20, 0x1C, 0x08,
	0x7F, 0xFF, 0x21, 0x3B, 0x9B, 0x00, 0xC8, 0x14, 0x43, 0x10, 0x00, 0x20, 0x00, 0x00, 0x08, 0x40,
	0xB5, 0x90, 0x40, 0xAD, 0xA0, 0x00, 0x0A, 0x07, 0x10, 0x4F, 0x84, 0x20, 0x1C, 0x08, 0x7F, 0xFF,
	0x21, 0x3B, 0xA5, 0x00, 0x48, 0x14, 0x43, 0x10, 0x00, 0x20, 0x00, 0x00, 0x08, 0x40, 0x35, 0x90,
	0x40, 0x2D, 0xA0, 0x00, 0x14, 0x07, 0x80, 0x0C, 0x07, 0x82, 0x03, 0x07, 0x04, 0x50, 0x84, 0x10,
	0x00, 0x20, 0x20, 0x02, 0x07, 0x00, 0x08, 0x21, 0x40, 0x00, 0x08, 0x00, 0x01, 0x11, 0x40, 0x50,
	0xA0, 0x00, 0x04, 0x00, 0x20, 0x81, 0x00, 0x80, 0x14, 0x43, 0x01, 0x00, 0x01, 0x04, 0x00, 0x11,
	0x02, 0x00, 0x21, 0x10, 0x9F, 0x84, 0x10, 0x20, 0x08, 0x40, 0x97, 0x90, 0x10, 0xBF, 0x84, 0x20,
	0x1D, 0x08, 0x40, 0xC6, 0xA0, 0x20, 0x8E, 0x08, 0x40, 0x72, 0x90, 0x40, 0x16, 0xA0, 0x10, 0x96,
	0x84, 0x10, 0x00, 0x08, 0x40, 0x9E, 0x90, 0x20, 0x36, 0x60, 0x20, 0x93, 0x00, 0x00, 0x14, 0x43,
	0x00, 0x01, 0x01, 0x00, 0x04, 0x11, 0x00, 0x02, 0x21, 0x10, 0x1F, 0x84, 0x10, 0x20, 0x08, 0x40,
	0x17, 0x90, 0x10, 0x3F, 0x84, 0x20, 0x1D, 0x08, 0x40, 0x46, 0xA0, 0x20, 0x8E, 0x08, 0x40, 0x70,
	0x90, 0x40, 0x96, 0xA0, 0x10, 0x16, 0x84, 0x10, 0x00, 0x08, 0x40, 0x1E, 0x90, 0x20, 0x34, 0x60,
	0x10, 0x65, 0x84, 0x50, 0x10, 0x08, 0x00, 0x00, 0x21, 0x84, 0x03, 0x07, 0x20, 0xF0, 0x60, 0x9F,
	0x03, 0x07, 0x40, 0x7E, 0xA0, 0x00, 0x10, 0x08, 0x40, 0x65, 0xA0, 0x20, 0x0D, 0x08, 0x40, 0x64,
	0x90, 0x40, 0x62, 0xA0, 0x00, 0x04, 0x00, 0x04, 0x1C, 0x44, 0x04, 0x1B, 0x44, 0x10, 0x60, 0x84,
	0x00, 0x00, 0x01, 0xFF, 0xFF, 0x21, 0x10, 0x42, 0x84, 0x20, 0x1E, 0x08, 0x40, 0x63, 0xA0, 0x10,
	0x07, 0x84, 0x10, 0x10, 0x08, 0x40, 0x55, 0xA0, 0x00, 0x20, 0x08, 0x40, 0x15, 0x90, 0x20, 0x0F,
	0x08, 0x20, 0x00, 0x11, 0x40, 0x71, 0xA0, 0x10, 0x15, 0x84, 0x80, 0x02, 0x07, 0x40, 0x7F, 0xA0,
	0x00, 0x20, 0x08, 0x40, 0x06, 0x90, 0x20, 0x0F, 0x08, 0x40, 0x6A, 0x90, 0x40, 0x60, 0xA0, 0x10,
	0xC2, 0x84, 0x20, 0x1E, 0x08, 0x40, 0x66, 0xA0, 0x10, 0x87, 0x84, 0x10, 0x10, 0x08, 0x40, 0x56,
	0xA0, 0x00, 0x20, 0x08, 0x40, 0x95, 0x90, 0x20, 0x0F, 0x08, 0x20, 0x00, 0x11, 0x40, 0x73, 0xA0,
	0x10, 0x95, 0x84, 0x88, 0x02, 0x07, 0x40, 0x7F, 0xA0, 0x00, 0x20, 0x08, 0x40, 0x86, 0x90, 0x20,
	0x0F, 0x08, 0x40, 0x6B, 0x90, 0x40, 0x60, 0xA0, 0x10, 0x56, 0x84, 0x20, 0x1F, 0x08, 0x40, 0x7B,
	0xA0, 0x70, 0x00, 0x08, 0x80, 0x00, 0x11, 0x22, 0x00, 0x60, 0x40, 0x00, 0x08, 0x40, 0x79, 0xA0,
	0x00, 0x08, 0x11, 0x10, 0x55, 0x84, 0x20, 0x1F, 0x08, 0x40, 0x7A, 0xA0, 0x70, 0x00, 0x08, 0x80,
	0x00, 0x11, 0x22, 0x00, 0x60, 0x50, 0x00, 0x08, 0x40, 0x79, 0xA0, 0x00, 0xFF, 0x11, 0x00, 0x00,
	0x00, 0x04, 0x6F, 0x84, 0x00, 0x08, 0x21, 0x10, 0x7E, 0x84, 0x60, 0x00, 0x08, 0x04, 0x00, 0x11,
	0x40, 0x7E, 0xA0, 0x10, 0xC1, 0x84, 0x20, 0x0F, 0x08, 0x70, 0x09, 0x07, 0x10, 0x10, 0x08, 0x40,
	0xC0, 0xA0, 0x20, 0x0F, 0x08, 0x7F, 0xFF, 0x11, 0x8F, 0x02, 0x07, 0x80, 0x00, 0x11, 0x08, 0x00,
	0x20, 0x08, 0xC1, 0x84, 0x40, 0xBD, 0x90, 0x9E, 0x02, 0x07, 0x40, 0x7F, 0xA0, 0x40, 0xEC, 0x90,
	0x04, 0x6E, 0x84, 0x00, 0x08, 0x21, 0x10, 0x7E, 0x84, 0x60, 0x00, 0x08, 0x00, 0x04, 0x11, 0x40,
	0x7E, 0xA0, 0x10, 0x41, 0x84, 0x20, 0x0F, 0x08, 0x70, 0x09, 0x07, 0x10, 0x10, 0x08, 0x40, 0x40,
	0xA0, 0x20, 0x0F, 0x08, 0x7F, 0xFF, 0x11, 0x8F, 0x02, 0x07, 0x80, 0x00, 0x11, 0x08, 0x00, 0x20,
	0x08, 0x41, 0x84, 0x40, 0x3D, 0x90, 0x9E, 0x02, 0x07, 0x40, 0x7F, 0xA0, 0x40, 0x6D, 0x90, 0x10,
	0x2D, 0x44, 0x21, 0x06, 0x00, 0x08, 0x00, 0x11, 0x20, 0x32, 0x60, 0x80, 0x14, 0x43, 0x10, 0x2C,
	0x44, 0x21, 0x0B, 0x00, 0x00, 0x08, 0x11, 0x20, 0x31, 0x60, 0x00, 0x14, 0x43, 0x04, 0x34, 0x44,
	0x40, 0x5B, 0xA0, 0x00, 0x04, 0x00, 0x10, 0x7E, 0x84, 0x60, 0x20, 0x08, 0x80, 0x00, 0x11, 0x50,
	0x00, 0x08, 0x3F, 0xFF, 0x11, 0x40, 0x7E, 0xA0, 0x08, 0xE8, 0x84, 0x20, 0x32, 0x50, 0x08, 0x68,
	0x84, 0x20, 0x31, 0x50, 0x08, 0x5E, 0x84, 0x20, 0x30, 0x50, 0x0F, 0xC2, 0x07, 0x10, 0x34, 0x44,
	0x10, 0x5B, 0x84, 0x6F, 0xF1, 0x07, 0x00, 0x00, 0x08, 0x02, 0x00, 0x21, 0x40, 0xFC, 0x90, 0x3D,
	0x97, 0x00, 0x04, 0xFC, 0x84, 0x00, 0x00, 0x21, 0x04, 0xFD, 0x84, 0x00, 0x08, 0x21, 0x00, 0x04,
	0x00, 0x10, 0x7E, 0x84, 0x60, 0x00, 0x08, 0xC0, 0x00, 0x11, 0x40, 0x7E, 0xA0, 0x04, 0x5B, 0x84,
	0x02, 0x00, 0x21, 0x70, 0x08, 0x07, 0x10, 0xFE, 0x84, 0x30, 0x20, 0x08, 0x00, 0x03, 0x11, 0x10,
	0x00, 0x08, 0x40, 0x59, 0x90, 0x04, 0xFF, 0x84, 0x40, 0x58, 0xA0, 0x10, 0x59, 0x84, 0x20, 0x0F,
	0x08, 0x40, 0x59, 0xA0, 0x20, 0x00, 0x11, 0x70, 0x20, 0x07, 0x10, 0x00, 0x08, 0x00, 0x0B, 0x11,
	0x0F, 0xE4, 0x07, 0x10, 0x59, 0x84, 0x00, 0x00, 0x08, 0x20, 0x30, 0x50, 0x40, 0x59, 0xA0, 0x70,
	0x06, 0x07, 0x10, 0x00, 0x08, 0x00, 0x0A, 0x11, 0x0F, 0xEC, 0x07, 0x08, 0x34, 0x44, 0x02, 0x10,
	0x11, 0x10, 0x58, 0x84, 0x20, 0x0F, 0x08, 0x40, 0x58, 0xA0, 0x20, 0x00, 0x11, 0x30, 0x08, 0x07,
	0x0F, 0xF4, 0x07, 0x10, 0x58, 0x84, 0x00, 0x00, 0x08, 0x20, 0x30, 0x50, 0x40, 0x58, 0xA0, 0x70,
	0x06, 0x07, 0x10, 0x00, 0x08, 0x00, 0x05, 0x11, 0x00, 0x04, 0x00, 0x10, 0x5A, 0x84, 0x00, 0x00,
	0x08, 0x00, 0x01, 0x11, 0x40, 0x5A, 0xA0, 0x08, 0x34, 0x44, 0x02, 0x00, 0x11, 0x30, 0x08, 0x07,
	0x60, 0x00, 0x08, 0x00, 0x00, 0x11, 0x40, 0x5A, 0xA0, 0x8F, 0x53, 0x07, 0x40, 0x7E, 0xA0, 0x00,
	0x04, 0x00, 0x3C, 0xA2, 0x00, 0x10, 0x00, 0x20, 0xA8, 0x14, 0x43, 0x04, 0xA7, 0x84, 0x20, 0x8E,
	0x08, 0x40, 0xC4, 0x90, 0x40, 0xAF, 0xA0, 0x20, 0x0F, 0x08, 0x40, 0xC5, 0x90, 0x40, 0xA7, 0xA0,
	0x3C, 0xAC, 0x00, 0x10, 0x00, 0x20, 0x28, 0x14, 0x43, 0x04, 0x27, 0x84, 0x20, 0x8E, 0x08, 0x40,
	0x44, 0x90, 0x40, 0x2F, 0xA0, 0x20, 0x0F, 0x08, 0x40, 0x45, 0x90, 0x40, 0x27, 0xA0, 0x00, 0x04,
	0x00, 0x10, 0xF0, 0x44, 0x50, 0x00, 0x08, 0xFF, 0xF7, 0x11, 0x93, 0x04, 0x07, 0x20, 0xF0, 0x60,
	0x04, 0x61, 0x84, 0x04, 0x5C, 0x84, 0x40, 0x57, 0xA0, 0x00, 0x04, 0x00, 0x10, 0x61, 0x84, 0x00,
	0x20, 0x08, 0x20, 0x1F, 0x08, 0x40, 0xFF, 0xA0, 0x10, 0x00, 0x08, 0x40, 0x5C, 0x90, 0x40, 0x57,
	0xA0, 0x04, 0x74, 0x84, 0x10, 0x00, 0x20, 0x00, 0x00, 0x08, 0x40, 0x74, 0xA0, 0x00, 0x01, 0x11,
	0x20, 0x05, 0x07, 0x00, 0x40, 0x21, 0x70, 0x00, 0x08, 0x7F, 0xFF, 0x21, 0x08, 0xFF, 0x84, 0x42,
	0x00, 0x90, 0x85, 0x02, 0x07, 0x20, 0xF0, 0x60, 0x7F, 0xFF, 0x11, 0x60, 0x20, 0x08, 0x00, 0xD0,
	0x11, 0x40, 0x00, 0x08, 0x00, 0x02, 0x11, 0x86, 0x1B, 0x07, 0x40, 0x74, 0xA0, 0x08, 0x66, 0x84,
	0x7F, 0xFF, 0x11, 0x8A, 0x02, 0x07, 0x89, 0x03, 0x07, 0x40, 0x7E, 0xA0, 0x00, 0x00, 0x11, 0x08,
	0x6F, 0x84, 0x00, 0x00, 0x11, 0x04, 0xF1, 0x84, 0x00, 0x40, 0x21, 0x10, 0x7E, 0x84, 0x60, 0x00,
	0x08, 0x40, 0x7E, 0xA0, 0x02, 0x00, 0x11, 0x60, 0x09, 0x07, 0x10, 0x20, 0x08, 0x40, 0xC3, 0x90,
	0x20, 0x2F, 0x08, 0x80, 0x00, 0x11, 0x70, 0x02, 0x07, 0x7F, 0xFF, 0x11, 0x10, 0x00, 0x08, 0x40,
	0x9D, 0x90, 0x40, 0x87, 0xA0, 0x08, 0x63, 0x84, 0x7F, 0xFF, 0x11, 0x82, 0x02, 0x07, 0x81, 0x03,
	0x07, 0x40, 0x7E, 0xA0, 0x00, 0x00, 0x11, 0x08, 0x6E, 0x84, 0x00, 0x00, 0x11, 0x04, 0xF0, 0x84,
	0x00, 0x40, 0x21, 0x10, 0x7E, 0x84, 0x60, 0x00, 0x08, 0x40, 0x7E, 0xA0, 0x00, 0x02, 0x11, 0x60,
	0x09, 0x07, 0x10, 0x20, 0x08, 0x40, 0x43, 0x90, 0x20, 0x2F, 0x08, 0x80, 0x00, 0x11, 0x70, 0x02,
	0x07, 0x7F, 0xFF, 0x11, 0x10, 0x00, 0x08, 0x40, 0x1D, 0x90, 0x40, 0x07, 0xA0, 0x10, 0xEC, 0x84,
	0x00, 0x10, 0x08, 0x10, 0xE7, 0x84, 0x40, 0xE7, 0xA0, 0x20, 0x0F, 0x08, 0x40, 0xEF, 0xA0, 0x10,
	0x6D, 0x84, 0x00, 0x10, 0x08, 0x10, 0x6C, 0x84, 0x40, 0x6C, 0xA0, 0x20, 0x0F, 0x08, 0x40, 0x7D,
	0xA0, 0x7F, 0xFF, 0x11, 0x00, 0x04, 0x00, 0x10, 0xEF, 0x84, 0x00, 0x10, 0x08, 0x10, 0xEE, 0x84,
	0x40, 0xEE, 0xA0, 0x20, 0x0F, 0x08, 0x40, 0xBD, 0xA0, 0x10, 0x7D, 0x84, 0x00, 0x10, 0x08, 0x10,
	0x7C, 0x84, 0x40, 0x7C, 0xA0, 0x20, 0x0F, 0x08, 0x40, 0x3D, 0xA0, 0x40, 0x00, 0x11, 0x3E, 0x70,
	0x00, 0xFB, 0xFF, 0x21, 0x6F, 0x14, 0x43, 0x3E, 0x73, 0x00, 0xFF, 0xFB, 0x21, 0x6E, 0x14, 0x43,
	0x3E, 0x76, 0x00, 0xFF, 0xFF, 0x21, 0x51, 0x14, 0x43, 0x3D, 0x2F, 0x00, 0x40, 0xAF, 0xA0, 0xA0,
	0x14, 0x43, 0x3D, 0x32, 0x00, 0x40, 0x2F, 0xA0, 0x20, 0x14, 0x43, 0x00, 0x04, 0x00, 0x3D, 0x36,
	0x00, 0x40, 0xA5, 0xA0, 0xB0, 0x14, 0x43, 0x3D, 0x39, 0x00, 0x40, 0x25, 0xA0, 0x30, 0x14, 0x43,
	0x3E, 0x50, 0x00, 0xB8, 0x14, 0x43, 0x40, 0xC2, 0xA0, 0x3E, 0x53, 0x00, 0x38, 0x14, 0x43, 0x40,
	0x42, 0xA0, 0x08, 0xBB, 0x84, 0x08, 0x3B, 0x84, 0xCB, 0x90, 0x11, 0x9E, 0x02, 0x07, 0xC7, 0x00,
	0x11, 0x40, 0x7F, 0xA0, 0x08, 0xBA, 0x84, 0x08, 0x3A, 0x84, 0x74, 0x70, 0x11, 0x9E, 0x02, 0x07,
	0x59, 0x00, 0x11, 0x40, 0x7F, 0xA0, 0x00, 0x04, 0x00, 0x3E, 0x99, 0x00, 0xFD, 0xFF, 0x21, 0xF1,
	0x14, 0x43, 0x3E, 0x9C, 0x00, 0xFF, 0xFD, 0x21, 0xF0, 0x14, 0x43, 0x00, 0x04, 0x00, 0x10, 0xB9,
	0x84, 0x20, 0x0F, 0x08, 0x40, 0xBE, 0xA0, 0x40, 0xB6, 0x90, 0x08, 0xBE, 0x84, 0x70, 0x02, 0x07,
	0x10, 0x20, 0x08, 0x7F, 0x80, 0x11, 0x10, 0xBE, 0x84, 0x00, 0x00, 0x08, 0x40, 0x53, 0xA0, 0x7F,
	0x80, 0x11, 0x99, 0x02, 0x07, 0x40, 0x7E, 0xA0, 0x40, 0xBE, 0x90, 0x10, 0x53, 0x84, 0x60, 0x00,
	0x08, 0xFF, 0x00, 0x21, 0x40, 0xF5, 0x90, 0x89, 0x01, 0x07, 0x9A, 0x08, 0x07, 0x40, 0xBE, 0x90,
	0x08, 0x53, 0x84, 0x00, 0x01, 0x11, 0x40, 0x7E, 0xA0, 0x10, 0x39, 0x84, 0x20, 0x0F, 0x08, 0x40,
	0x3E, 0xA0, 0x40, 0x36, 0x90, 0x08, 0x3E, 0x84, 0x70, 0x02, 0x07, 0x10, 0x20, 0x08, 0x7F, 0x80,
	0x11, 0x10, 0x3E, 0x84, 0x00, 0x00, 0x08, 0x40, 0x52, 0xA0, 0x7F, 0x80, 0x11, 0x91, 0x02, 0x07,
	0x40, 0x7E, 0xA0, 0x40, 0x3E, 0x90, 0x10, 0x52, 0x84, 0x60, 0x00, 0x08, 0xFF, 0x00, 0x21, 0x40,
	0xF5, 0x90, 0x81, 0x01, 0x07, 0x92, 0x08, 0x07, 0x40, 0x3E, 0x90, 0x08, 0x52, 0x84, 0x00, 0x01,
	0x11, 0x40, 0x7E, 0xA0, 0x00, 0x04, 0x00, 0x22, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x84,
	0x00, 0x10, 0x08, 0x40, 0x73, 0xA0, 0x20, 0x0F, 0x08, 0x40, 0xFF, 0x90, 0x40, 0x8D, 0xA0, 0x10,
	0x71, 0x84, 0x00, 0x10, 0x08, 0x40, 0x71, 0xA0, 0x20, 0x1F, 0x08, 0x40, 0x0D, 0xA0, 0x10, 0xFF,
	0x84, 0x20, 0x0F, 0x08, 0x40, 0xF5, 0x90, 0x40, 0x51, 0xA0, 0x04, 0xBC, 0x84, 0x04, 0x3C, 0x84,
	0x00, 0x00, 0x21, 0x04, 0xF1, 0x84, 0x04, 0xF0, 0x84, 0x00, 0x40, 0x21, 0x10, 0x7E, 0x84, 0x60,
	0x00, 0x08, 0x02, 0x02, 0x11, 0x40, 0x7E, 0xA0, 0x60, 0x0B, 0x07, 0x10, 0x00, 0x08, 0x40, 0xF3,
	0x90, 0x20, 0x1D, 0x07, 0x60, 0x00, 0x08, 0x00, 0x00, 0x11, 0x40, 0x51, 0xA0, 0x3E, 0xBF, 0x00,
	0x40, 0x87, 0xA0, 0x80, 0x14, 0x43, 0x3E, 0xC2, 0x00, 0x40, 0x07, 0xA0, 0x00, 0x14, 0x43, 0x00,
	0x04, 0x00, 0x3E, 0xC6, 0x00, 0x40, 0x85, 0xA0, 0x88, 0x14, 0x43, 0x3E, 0xC9, 0x00, 0x40, 0x05,
	0xA0, 0x08, 0x14, 0x43, 0x00, 0x04, 0x00, 0x3E, 0xCD, 0x00, 0x40, 0x8D, 0xA0, 0x98, 0x14, 0x43,
	0x3E, 0xD0, 0x00, 0x40, 0x0D, 0xA0, 0x18, 0x14, 0x43, 0x00, 0x04, 0x00, 0x00, 0x01, 0x07, 0x00,
	0x02, 0x07, 0x00, 0x03, 0x07, 0x00, 0x05, 0x07, 0x00, 0x0D, 0x07, 0x00, 0x15, 0x07, 0x00, 0x3F,
	0x07, 0x00, 0x73, 0x07, 0x00, 0x7B, 0x07, 0x00, 0x95, 0x07, 0x00, 0xB3, 0x07, 0x01, 0x16, 0x07,
	0x01, 0x2C, 0x07, 0x01, 0xF6, 0x07, 0x02, 0x28, 0x07, 0x00, 0x10, 0x07, 0x1F, 0xFF, 0x07, 0x20,
	0x03, 0x60, 0x0F, 0x5C, 0x07, 0x08, 0xFA, 0x84, 0x04, 0x11, 0x44, 0xFF, 0x00, 0x11, 0x2F, 0x60,
	0x07, 0x70, 0x10, 0x08, 0x00, 0xF0, 0x21, 0x50, 0x00, 0x08, 0x00, 0xF0, 0x21, 0x40, 0xF9, 0x90,
	0x00, 0x08, 0x07, 0x3E, 0x74, 0x00, 0x0F, 0x68, 0x07, 0x04, 0x51, 0x84, 0x40, 0xF2, 0xA0, 0x90,
	0x03, 0x07, 0x40, 0xF9, 0xA0, 0x3F, 0x6D, 0x07, 0x70, 0x00, 0x08, 0x00, 0x7F, 0x11, 0x40, 0xF8,
	0xA0, 0x9D, 0x09, 0x07, 0x20, 0x12, 0x60, 0x08, 0xFA, 0x84, 0x04, 0x11, 0x44, 0x3E, 0x51, 0x00,
	0x00, 0x18, 0x07, 0x48, 0x80, 0x11, 0x08, 0x09, 0x44, 0x40, 0x75, 0x90, 0x7F, 0xEF, 0x07, 0x10,
	0x00, 0x20, 0x00, 0x10, 0x08, 0xFF, 0xFF, 0x21, 0x06, 0x00, 0x84, 0x40, 0xFB, 0xA0, 0x60, 0x00,
	0x08, 0x00, 0x00, 0x21, 0x40, 0xFF, 0x90, 0x10, 0xFB, 0x84, 0x60, 0x20, 0x08, 0x40, 0xFB, 0x90,
	0x30, 0x00, 0x08, 0x00, 0x08, 0x11, 0x3D, 0xE7, 0x00, 0x04, 0xFB, 0x84, 0x3D, 0xE9, 0x00, 0x04,
	0xFF, 0x84, 0x40, 0xF8, 0xA0, 0x04, 0x11, 0x44, 0x8F, 0xFF, 0x07, 0x20, 0x19, 0x60, 0x3E, 0xCF,
	0x00, 0x00, 0x03, 0x00, 0x8F, 0xFF, 0x07, 0x20, 0x19, 0x60, 0x08, 0x1C, 0x44, 0x04, 0x1B, 0x44,
	0x00, 0x38, 0x07, 0x00, 0x01, 0x00, 0x00, 0x3A, 0x07, 0x00, 0x02, 0x00, 0x20, 0x05, 0x00, 0x4C,
	0x00, 0x21, 0x20, 0x07, 0x00, 0x48, 0x24, 0x21, 0x20, 0x09, 0x00, 0x48, 0x14, 0x21, 0x31, 0x06,
	0x11, 0x20, 0x0C, 0x00, 0x48, 0x22, 0x21, 0x20, 0x0E, 0x00, 0x48, 0x12, 0x21, 0x90, 0xFA, 0x11,
	0x20, 0x11, 0x00, 0x48, 0x20, 0x21, 0x20, 0x13, 0x00, 0x48, 0x10, 0x21, 0x00, 0x80, 0x11, 0x20,
	0x16, 0x00, 0x4C, 0x02, 0x21, 0x1F, 0x18, 0x43, 0x04, 0x72, 0x44, 0x04, 0x37, 0x21, 0x3F, 0xFA,
	0x07, 0x70, 0x20, 0x08, 0x00, 0x00, 0x11, 0x10, 0x2D, 0x44, 0x10, 0x2C, 0x44, 0x00, 0x20, 0x08,
	0x10, 0x00, 0x11, 0x00, 0x00, 0x08, 0x00, 0x00, 0x11, 0x80, 0x00, 0x21, 0x04, 0x73, 0x44, 0x07,
	0x07, 0x21, 0x04, 0x72, 0x44, 0x00, 0x07, 0x21, 0x04, 0x73, 0x44, 0x07, 0x77, 0x21, 0x04, 0x73,
	0x44, 0x00, 0x70, 0x21, 0x04, 0x2E, 0x44, 0x04, 0x2D, 0x44, 0x04, 0x2C, 0x44, 0x80, 0x00, 0x21,
	0x08, 0x28, 0x44, 0x01, 0x11, 0x11, 0x08, 0x5D, 0x84, 0x10, 0x00, 0x10, 0x10, 0x00, 0x08, 0x40,
	0x00, 0x21, 0x30, 0x04, 0x07, 0x40, 0xFF, 0x90, 0x50, 0x20, 0x08, 0xC0, 0x00, 0x11, 0x10, 0xFF,
	0x84, 0x00, 0x20, 0x08, 0x00, 0x40, 0x11, 0x40, 0x00, 0x08, 0x00, 0x01, 0x11, 0x20, 0x51, 0x60,
	0x10, 0x00, 0x44, 0x60, 0x00, 0x08, 0x40, 0x54, 0x90, 0x20, 0x00, 0x60, 0x00, 0x7C, 0x07, 0x81,
	0x44, 0x07, 0x80, 0x03, 0x07, 0x40, 0xF8, 0xA0, 0x48, 0xC0, 0x11, 0x00, 0x7A, 0x07, 0x00, 0x7B,
	0x07, 0x00, 0x7C, 0x07, 0x00, 0x04, 0x07, 0x00, 0x7E, 0x07, 0x00, 0x7F, 0x07, 0x00, 0x80, 0x07,
	0x00, 0x56, 0x07, 0x00, 0x82, 0x07, 0x00, 0x83, 0x07, 0x00, 0x84, 0x07, 0x00, 0x75, 0x07, 0x00,
	0x86, 0x07, 0x00, 0x85, 0x07, 0x00, 0x88, 0x07, 0x00, 0x89, 0x07, 0x0F, 0xEF, 0x07, 0x1F, 0xFF,
	0x07, 0xFF, 0x00, 0x11, 0x10, 0x00, 0x20, 0x30, 0x10, 0x08, 0x00, 0x01, 0x21, 0x50, 0x00, 0x08,
	0x00, 0x0F, 0x21, 0x40, 0xF9, 0x90, 0x30, 0x93, 0x07, 0x70, 0x10, 0x08, 0x00, 0x80, 0x21, 0x50,
	0x00, 0x08, 0x00, 0xF0, 0x21, 0x08, 0xF9, 0x84, 0x04, 0xF8, 0x84, 0x2F, 0xFF, 0x07, 0x3E, 0x57,
	0x00, 0x04, 0xF5, 0x84, 0x30, 0xFF, 0x21, 0x04, 0xF3, 0x84, 0x01, 0x00, 0x21, 0x04, 0xF2, 0x84,
	0x02, 0x00, 0x21, 0x04, 0xF1, 0x84, 0x04, 0xF0, 0x84, 0x04, 0x5A, 0x84, 0x00, 0x00, 0x21, 0x04,
	0xF6, 0x84, 0x09, 0x55, 0x21, 0x04, 0xFA, 0x84, 0x40, 0x00, 0x21, 0x04, 0xF7, 0x84, 0x01, 0x04,
	0x21, 0x04, 0x70, 0x44, 0x06, 0x66, 0x21, 0x04, 0x3B, 0x44, 0x04, 0x39, 0x44, 0x00, 0x80, 0x21,
	0x04, 0x3C, 0x44, 0x2A, 0x0F, 0x21, 0x04, 0x2F, 0x44, 0x00, 0x44, 0x21, 0x04, 0x29, 0x44, 0x00,
	0x00, 0x21, 0x03, 0x19, 0x42, 0x4E, 0x19, 0x43, 0x0C, 0x59, 0x43, 0x1F, 0x18, 0x43, 0x75, 0x00,
	0x43, 0x04, 0x22, 0x44, 0x03, 0x07, 0x21, 0x04, 0x21, 0x44, 0x11, 0x11, 0x21, 0x04, 0x20, 0x44,
	0x33, 0x33, 0x21, 0x00, 0x00, 0x42, 0xC0, 0x3D, 0x42, 0x80, 0x3D, 0x43, 0x04, 0x35, 0x44, 0x00,
	0x00, 0x21, 0x04, 0x05, 0x43, 0x42, 0xD2, 0x00
};

static uint8_t bu63164gwl_act_init_mem_settings[] = {
	0x88, 0xef, 0x00, 0x00, 0x00, 0x20, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0xab, 0x0a, 0x00, 0x40,
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x87, 0x82, 0xb7, 0x7e,
	0xa2, 0x00, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f,
	0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0x00, 0x60, 0xc3, 0x55, 0x85, 0x2b, 0x9a, 0x19, 0x00, 0x60,
	0xdf, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0xf6, 0x99, 0x52, 0x98, 0xd6, 0x5b,
	0x7d, 0x72, 0xe2, 0x39, 0x00, 0x20, 0x00, 0x8a, 0x00, 0x40, 0x00, 0x19, 0x00, 0x7f, 0xff, 0x7f,
	0x80, 0x07, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x90, 0xcb, 0x70, 0x74, 0xfe, 0x7f,
	0x04, 0x14, 0x00, 0x00, 0xfe, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xe1, 0xf5, 0xc8, 0x5c, 0x00, 0x7e,
	0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xda, 0x3d, 0xda, 0x3d, 0x00, 0x24,
	0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x30, 0x00, 0x6c,
	0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x7c,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x20, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x60,
	0x00, 0x20, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x60,
	0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x1b, 0x1c,
	0xc4, 0x04, 0x00, 0x19, 0x2b, 0xf0, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xcc, 0x59, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0xf6, 0x99, 0x52, 0x98, 0xd6, 0x5b,
	0x7d, 0x72, 0xe2, 0x39, 0x00, 0x20, 0x00, 0x8a, 0x00, 0x40, 0x00, 0x19, 0x00, 0x7f, 0xff, 0x7f,
	0x80, 0x07, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x90, 0xcb, 0x70, 0x74, 0xfe, 0x7f,
	0x04, 0x14, 0x00, 0x00, 0xfe, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xe1, 0xf5, 0xc8, 0x5c, 0x00, 0x7e,
	0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xda, 0x3d, 0xda, 0x3d, 0x00, 0x24,
	0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x30, 0x00, 0x6c,
	0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x7c,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x20, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x60,
	0x00, 0x20, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x60,
	0x00, 0x20
};

static int32_t bu63164gwl_actuator_write_ois(struct msm_actuator_ctrl_t *a_ctrl,
											uint8_t cmd_type, uint8_t addr,uint16_t data)
{
	int32_t rc = -EFAULT;
	struct msm_camera_i2c_seq_reg_setting conf_sec_array;
	struct msm_camera_i2c_seq_reg_array reg_sec_setting;

	CDBG("%s L.%d cmd:0x%02X adr:0x%02X", __func__, __LINE__, cmd_type, addr);

	if((cmd_type != BU63164GWL_OIS_CMD_SPE) &&
	   (cmd_type != BU63164GWL_OIS_CMD_MEM) &&
	   (cmd_type != BU63164GWL_OIS_CMD_PER)) {
		pr_err("%s L.%d invalid cmd 0x%x", __func__, __LINE__, cmd_type);
		return rc;
	}

	conf_sec_array.addr_type = MSM_ACTUATOR_BYTE_ADDR;
	conf_sec_array.delay = 0;
	conf_sec_array.reg_setting = &reg_sec_setting;
	conf_sec_array.size = 1;
	memset(&reg_sec_setting, 0, sizeof(struct msm_camera_i2c_seq_reg_array));

	if (cmd_type == BU63164GWL_OIS_CMD_SPE) {
		uint16_t client_addr_type;
		client_addr_type = a_ctrl->i2c_client.addr_type;
		a_ctrl->i2c_client.addr_type = MSM_CAMERA_I2C_BYTE_ADDR;
//		reg_sec_setting.reg_addr = cmd_type;
//		reg_sec_setting.reg_data_size = 1;
//		reg_sec_setting.reg_data[0] = addr;
		rc = a_ctrl->i2c_client.i2c_func_tbl->
			i2c_write(&a_ctrl->i2c_client, cmd_type, addr,
			MSM_CAMERA_I2C_BYTE_DATA);
		a_ctrl->i2c_client.addr_type = client_addr_type;
	} else {
		reg_sec_setting.reg_addr = cmd_type;
		reg_sec_setting.reg_data_size = 3;
		reg_sec_setting.reg_data[0] = addr;
		reg_sec_setting.reg_data[1] = (uint8_t)(data & 0x00FF);
		reg_sec_setting.reg_data[2] = (uint8_t)((data & 0xFF00) >> 8);
		rc = a_ctrl->i2c_client.i2c_func_tbl->
			i2c_write_seq_table(&a_ctrl->i2c_client,
			&conf_sec_array);

	}

	CDBG("%s L.%d rc:%d", __func__, __LINE__, rc);

	return rc;
}

static struct msm_actuator bu63164gwl_act_table;

static struct i2c_driver bu63164gwl_act_i2c_driver;
static struct msm_actuator *actuators[] = {
	&bu63164gwl_act_table,
};

static void bu63164gwl_act_parse_i2c_params(struct msm_actuator_ctrl_t *a_ctrl,
	int16_t next_lens_position, uint32_t hw_params, uint16_t delay)
{
#if 0
	struct msm_actuator_reg_params_t *write_arr = a_ctrl->reg_tbl;
	uint32_t hw_dword = hw_params;
	uint16_t i2c_byte1 = 0, i2c_byte2 = 0;
	uint16_t value = 0;
	uint32_t size = a_ctrl->reg_tbl_size, i = 0;
	struct msm_camera_i2c_reg_array *i2c_tbl = a_ctrl->i2c_reg_tbl;
	CDBG("Enter\n");
	
	if( a_ctrl->i2c_reg_tbl == NULL || write_arr == NULL )
		return;
	
	for (i = 0; i < size; i++) {
		CDBG("next_lens_position =%d\n", next_lens_position );
		CDBG("data_shift =%d\n",write_arr[i].data_shift );
		CDBG("hw_mask    =%d\n",write_arr[i].hw_mask );
		CDBG("hw_shift   =%d\n",write_arr[i].hw_shift);
		CDBG("reg_addr   =%x\n",write_arr[i].reg_addr );
		CDBG("hw_params  =%x\n",hw_params );
		
		if (write_arr[i].reg_write_type == MSM_ACTUATOR_WRITE_DAC) {
			value = (next_lens_position <<write_arr[i].data_shift) |((hw_dword & write_arr[i].hw_mask) >>write_arr[i].hw_shift);
			if (write_arr[i].reg_addr != 0xFFFF) {
				i2c_byte1 = write_arr[i].reg_addr;
				i2c_byte2 = value;
				if (size != (i+1)) {
					i2c_byte2 = value & 0xFF;
					CDBG("byte1:0x%x, byte2:0x%x\n",i2c_byte1, i2c_byte2);
					i2c_tbl[a_ctrl->i2c_tbl_index].reg_addr = i2c_byte1;
					i2c_tbl[a_ctrl->i2c_tbl_index].reg_data = i2c_byte2;
					i2c_tbl[a_ctrl->i2c_tbl_index].delay    = 0;
					a_ctrl->i2c_tbl_index++;
					i++;
					i2c_byte1 = write_arr[i].reg_addr;
					i2c_byte2 = (value & 0xFF00) >> 8;
				}
			} else {
				i2c_byte1 = (value & 0xFF00) >> 8;
				i2c_byte2 = value & 0xFF;
			}
		} else {
			i2c_byte1 = write_arr[i].reg_addr;
			i2c_byte2 = (hw_dword & write_arr[i].hw_mask) >>write_arr[i].hw_shift;
		}
		CDBG_DEB("i2c_byte1:0x%x, i2c_byte2:0x%x\n", i2c_byte1, i2c_byte2);
		i2c_tbl[a_ctrl->i2c_tbl_index].reg_addr = i2c_byte1;
		i2c_tbl[a_ctrl->i2c_tbl_index].reg_data = i2c_byte2;
		i2c_tbl[a_ctrl->i2c_tbl_index].delay    = delay;
		a_ctrl->i2c_tbl_index++;
	}
#else
	struct msm_camera_i2c_seq_reg_setting conf_sec_array;
	struct msm_camera_i2c_seq_reg_array reg_sec_setting;
	int32_t rc = -EFAULT;

	CDBG("Enter\n");
	
	if( a_ctrl->i2c_reg_tbl == NULL)
		return;

#if 0
	{
		uint16_t client_addr_type;
		uint16_t data;
		client_addr_type = a_ctrl->i2c_client.addr_type;
		a_ctrl->i2c_client.addr_type = MSM_CAMERA_I2C_WORD_ADDR;
		
		rc = a_ctrl->i2c_client.i2c_func_tbl->
			i2c_read(&a_ctrl->i2c_client,((BU63164GWL_OIS_CMD_MEM << 8) | 0xF7), &data,
			MSM_CAMERA_I2C_WORD_DATA);
		
		CDBG("%s OIS_STS=0x%0x\n", __func__, data);
		
		a_ctrl->i2c_client.addr_type = client_addr_type;
	}
#endif

	conf_sec_array.addr_type = MSM_ACTUATOR_BYTE_ADDR;
	conf_sec_array.delay = 0;
	conf_sec_array.reg_setting = &reg_sec_setting;
	conf_sec_array.size = 1;

	memset(&reg_sec_setting, 0, sizeof(struct msm_camera_i2c_seq_reg_array));

	reg_sec_setting.reg_addr = 0xF0;
	reg_sec_setting.reg_data[0] = 0x90;
	reg_sec_setting.reg_data[1] = 0x00;
	reg_sec_setting.reg_data[2] = (next_lens_position & 0xFF00) >> 8;
	reg_sec_setting.reg_data[3] = (next_lens_position & 0x00FF);

	reg_sec_setting.reg_data_size = 4;

	CDBG("reg_sec_setting.reg_data[2]:0x%x, reg_sec_setting.reg_data[3]:0x%x\n", reg_sec_setting.reg_data[2], reg_sec_setting.reg_data[3]);
	rc = a_ctrl->i2c_client.i2c_func_tbl->
			i2c_write_seq_table(&a_ctrl->i2c_client,
			&conf_sec_array);
	
	CDBG("%s rc=%d\n", __func__, rc);
	
#endif
	CDBG("Exit\n");
}

static int32_t bu63164gwl_act_init_focus(struct msm_actuator_ctrl_t *a_ctrl,
	uint16_t size, enum msm_actuator_data_type type,
	struct reg_settings_t *settings)
{
	int32_t rc = -EFAULT;
	int32_t i = 0;
	CDBG("Enter\n");
	
	/* 10msec delay */
	/* no delay */
	//usleep_range(10000, 11000);
	
	for (i = 0; i < size; i++) {
		switch (type) {
		case MSM_ACTUATOR_BYTE_DATA:
			rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write(
				&a_ctrl->i2c_client,
				settings[i].reg_addr,
				settings[i].reg_data, MSM_CAMERA_I2C_BYTE_DATA);
			break;
		case MSM_ACTUATOR_WORD_DATA:
			rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write(
				&a_ctrl->i2c_client,
				settings[i].reg_addr,
				settings[i].reg_data, MSM_CAMERA_I2C_WORD_DATA);
			break;
		default:
			pr_err("Unsupport data type: %d\n", type);
			break;
		}
		if (rc < 0)
			break;
	}

	a_ctrl->curr_step_pos = 0;
	CDBG("Exit\n");
	return rc;
}

static void bu63164gwl_act_write_focus(
	struct msm_actuator_ctrl_t *a_ctrl,
	uint16_t curr_lens_pos,
	struct damping_params_t *damping_params,
	int8_t sign_direction,
	int16_t next_lens_pos)
{
	CDBG("Enter\n");
	
	if (curr_lens_pos != next_lens_pos) {
		CDBG("bu63164gwl_act_write_focus2 %d %d %d \n", curr_lens_pos, next_lens_pos, damping_params->hw_params );
		
		a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl,
			next_lens_pos, damping_params->hw_params, 0);
	}
	CDBG("Exit\n");
}

static int32_t bu63164gwl_act_move_focus(
	struct msm_actuator_ctrl_t *a_ctrl,
	struct msm_actuator_move_params_t *move_params)
{
	int32_t rc = 0;
	int8_t sign_dir = move_params->sign_dir;
	uint16_t step_boundary = 0;
	uint16_t target_step_pos = 0;
	uint16_t target_lens_pos = 0;
	int16_t dest_step_pos = move_params->dest_step_pos;
	uint16_t curr_lens_pos = 0;
	int dir = move_params->dir;
	int32_t num_steps = move_params->num_steps;
//	struct msm_camera_i2c_reg_setting reg_setting;

	CDBG("called, dir %d, num_steps %d\n", dir, num_steps);

	if (dest_step_pos == a_ctrl->curr_step_pos)
		return rc;

	if( a_ctrl->step_position_table == NULL )
		return -ENOMEM;
	
	curr_lens_pos = a_ctrl->step_position_table[a_ctrl->curr_step_pos];
	a_ctrl->i2c_tbl_index = 0;
	
	CDBG_DEB("curr_step_pos =%d dest_step_pos =%d curr_lens_pos=%d\n", a_ctrl->curr_step_pos, dest_step_pos, curr_lens_pos);

	while (a_ctrl->curr_step_pos != dest_step_pos) {
		step_boundary = a_ctrl->region_params[a_ctrl->curr_region_index].step_bound[dir];
		
		if ((dest_step_pos * sign_dir) <= (step_boundary * sign_dir)) {

			target_step_pos = dest_step_pos;
			target_lens_pos =
				a_ctrl->step_position_table[target_step_pos];
			
			a_ctrl->func_tbl->actuator_write_focus(a_ctrl,
					curr_lens_pos,
					&(move_params->
						ringing_params[a_ctrl->
						curr_region_index]),
					sign_dir,
					target_lens_pos);
			curr_lens_pos = target_lens_pos;

		} else {
			target_step_pos = step_boundary;
			target_lens_pos = a_ctrl->step_position_table[target_step_pos];
			
			a_ctrl->func_tbl->actuator_write_focus(a_ctrl,
					curr_lens_pos,
					&(move_params->ringing_params[a_ctrl->
						curr_region_index]),
					sign_dir,
					target_lens_pos);
			curr_lens_pos = target_lens_pos;

			a_ctrl->curr_region_index += sign_dir;
		}
		a_ctrl->curr_step_pos = target_step_pos;
	}

#if 0
	reg_setting.reg_setting = a_ctrl->i2c_reg_tbl;
	reg_setting.data_type = a_ctrl->i2c_data_type;
	reg_setting.size = a_ctrl->i2c_tbl_index;
	rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_write_table_w_microdelay(
		&a_ctrl->i2c_client, &reg_setting);
	if (rc < 0) {
		pr_err("i2c write error:%d\n", rc);
		return rc;
	}
#endif
	a_ctrl->i2c_tbl_index = 0;
	CDBG("Exit\n");

	return rc;
}

static int32_t bu63164gwl_act_init_step_table(struct msm_actuator_ctrl_t *a_ctrl,
	struct msm_actuator_set_info_t *set_info)
{
	int16_t code_per_step = 0;
	int16_t cur_code = 0;
	int16_t step_index = 0, region_index = 0;
	uint16_t step_boundary = 0;
	uint32_t max_code_size = 1;
	uint16_t data_size = set_info->actuator_params.data_size;
	CDBG("Enter\n");

	for (; data_size > 0; data_size--)
		max_code_size *= 2;

	if( a_ctrl->step_position_table ){
		kfree(a_ctrl->step_position_table);
		a_ctrl->step_position_table = NULL;
	}
	/* Fill step position table */
	a_ctrl->step_position_table =
		kmalloc(sizeof(uint16_t) *
		(set_info->af_tuning_params.total_steps + 1), GFP_KERNEL);

	if (a_ctrl->step_position_table == NULL)
		return -ENOMEM;

	cur_code = set_info->af_tuning_params.initial_code;
	a_ctrl->step_position_table[step_index++] = cur_code;
	
	CDBG_DEB("step table[%d] = %d\n", (step_index-1), a_ctrl->step_position_table[(step_index-1)]);
	CDBG("region_size =%d\n", a_ctrl->region_size );
	
	for (region_index = 0;
		region_index < a_ctrl->region_size;
		region_index++) {
		
		code_per_step =
			a_ctrl->region_params[region_index].code_per_step;
		step_boundary =
			a_ctrl->region_params[region_index].
			step_bound[MOVE_NEAR];
		
		CDBG("region_index =%d code_per_step =%d boudary=%d max_code_size=%d \n", region_index, code_per_step, step_boundary, max_code_size );
		
		for (; step_index <= step_boundary;
			step_index++) {
			cur_code += code_per_step;
			
			if (cur_code < max_code_size){
				CDBG_DEB("step table[%d] = %d\n", step_index, cur_code );
				a_ctrl->step_position_table[step_index] =
					cur_code;
				
			}else {
				for (; step_index <
					set_info->af_tuning_params.total_steps;
					step_index++){
						CDBG_DEB("step table[%d] = %d\n", step_index, max_code_size );
					a_ctrl->
						step_position_table[
						step_index] =
						max_code_size;
				}
			}
		}
	}
	CDBG("Exit\n");
	return 0;
}

static int32_t bu63164gwl_act_set_default_focus(
	struct msm_actuator_ctrl_t *a_ctrl,
	struct msm_actuator_move_params_t *move_params)
{
	int32_t rc = 0;
	CDBG("Enter\n");

	if (a_ctrl->curr_step_pos != 0)
		rc = a_ctrl->func_tbl->actuator_move_focus(a_ctrl, move_params);
	CDBG("Exit\n");
	return rc;
}

static int32_t bu63164gwl_act_power_down(struct msm_actuator_ctrl_t *a_ctrl)
{
	int32_t rc = 0;
	CDBG("Enter\n");
#if 0
	if (a_ctrl->vcm_enable) {
		rc = gpio_direction_output(a_ctrl->vcm_pwd, 0);
		if (!rc)
			gpio_free(a_ctrl->vcm_pwd);
	}
#endif
	
	if (a_ctrl->act_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
		if( a_ctrl->cci_inited ){
			rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_util(
				&a_ctrl->i2c_client, MSM_CCI_RELEASE);
			if (rc < 0)
				pr_err("cci_release failed\n");
		}
	}
	if( a_ctrl->step_position_table ){
		kfree(a_ctrl->step_position_table);
	}
	if( a_ctrl->i2c_reg_tbl ){
		kfree(a_ctrl->i2c_reg_tbl);
	}
	a_ctrl->step_position_table = NULL;
	a_ctrl->i2c_reg_tbl = NULL;
	a_ctrl->i2c_tbl_index = 0;
	
	a_ctrl->num_instance = 0;
	a_ctrl->cci_inited   = 0;
	
	CDBG("Exit\n");
	return rc;
}

static int32_t bu63164gwl_act_init(struct msm_actuator_ctrl_t *a_ctrl,
	struct msm_actuator_set_info_t *set_info) {
	struct reg_settings_t *init_settings = NULL;
	int32_t rc = -EFAULT;
	uint16_t i = 0;
	struct msm_camera_cci_client *cci_client = NULL;
#if defined(CONFIG_MACH_LYNX_DL60)
	uint16_t rev = 0;
#endif
	CDBG("Enter\n");
	
	for (i = 0; i < ARRAY_SIZE(actuators); i++) {
		if (set_info->actuator_params.act_type ==
			actuators[i]->act_type) {
			a_ctrl->func_tbl = &actuators[i]->func_tbl;
			rc = 0;
		}
	}
	if (rc < 0) {
		pr_err("Actuator function table not found\n");
		return rc;
	}

	a_ctrl->region_size = set_info->af_tuning_params.region_size;
	if (a_ctrl->region_size > MAX_ACTUATOR_REGION) {
		pr_err("MAX_ACTUATOR_REGION is exceeded.\n");
		return -EFAULT;
	}
	a_ctrl->pwd_step = set_info->af_tuning_params.pwd_step;
	a_ctrl->total_steps = set_info->af_tuning_params.total_steps;

	if (copy_from_user(&a_ctrl->region_params,
		(void *)set_info->af_tuning_params.region_params,
		a_ctrl->region_size * sizeof(struct region_params_t)))
		return -EFAULT;

	if (a_ctrl->act_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
		
#if 1
		if( !a_ctrl->cci_inited ){
			rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_util(
				&a_ctrl->i2c_client, MSM_CCI_INIT);
			if (rc < 0)
				pr_err("cci_init failed\n");
			
		a_ctrl->cci_inited = 1;
		}
#endif
		cci_client = a_ctrl->i2c_client.cci_client;
		cci_client->sid =
			set_info->actuator_params.i2c_addr >> 1;
		cci_client->retries = 3;
		cci_client->id_map = 0;
		cci_client->cci_i2c_master = a_ctrl->cci_master;
	} else {
		a_ctrl->i2c_client.client->addr =
			set_info->actuator_params.i2c_addr;
	}

	CDBG("%s a_ctrl->fw_inited=%d\n", __func__, a_ctrl->fw_inited);
	if(a_ctrl->fw_inited ==0){
		struct msm_camera_i2c_seq_reg_setting conf_sec_array;
		struct msm_camera_i2c_seq_reg_array reg_sec_setting;

		rev = sh_boot_get_hw_revision();
		
		CDBG("%s rev=0x%0x\n", __func__, rev);
		if(rev == 0x00){
			int length = 0;
			char *data_pos=NULL;
			int write_len = 0;
			
			conf_sec_array.addr_type = MSM_ACTUATOR_BYTE_ADDR;
			conf_sec_array.delay = 0;
			conf_sec_array.reg_setting = &reg_sec_setting;
			conf_sec_array.size = 1;

			length = sizeof(bu63164gwl_act_init_fw_settings);
			data_pos = &bu63164gwl_act_init_fw_settings[0];
			
			data_pos++;
			write_len = 1;
			
			CDBG("%s bu63164gwl_act_init_fw_settings length=%d\n", __func__, length);
			memset(&reg_sec_setting, 0, sizeof(struct msm_camera_i2c_seq_reg_array));
			do{
				reg_sec_setting.reg_addr = 0x80;
				if((length - write_len) > 7){
					for(i=0;i<7;i++){
						reg_sec_setting.reg_data[i] = *data_pos;
						data_pos++;
					}
					reg_sec_setting.reg_data_size = 7;
					write_len += 7;
				} else {
					if((length - write_len) == 0){
						pr_err("%s:%d firm write error\n", __func__, __LINE__);
					}
					memset(&reg_sec_setting, 0, sizeof(struct msm_camera_i2c_seq_reg_array));
					for(i=0;i<(length - write_len);i++){
						reg_sec_setting.reg_data[i] = *data_pos;
						data_pos++;
					}
					reg_sec_setting.reg_data_size = length - write_len;
					write_len += length - write_len;
				}
				
				rc = a_ctrl->i2c_client.i2c_func_tbl->
					i2c_write_seq_table(&a_ctrl->i2c_client,
					&conf_sec_array);

			}while(write_len < length);
			CDBG("%s write_len=%d length=%d\n", __func__, write_len, length);

			length = sizeof(bu63164gwl_act_init_mem_settings);
			data_pos = &bu63164gwl_act_init_mem_settings[0];
			
			data_pos++;
			write_len = 1;
			
			CDBG("%s bu63164gwl_act_init_mem_settings length=%d\n", __func__, length);
			memset(&reg_sec_setting, 0, sizeof(struct msm_camera_i2c_seq_reg_array));
			do{
				reg_sec_setting.reg_addr = 0x88;
				if((length - write_len) > 7){
					for(i=0;i<7;i++){
						reg_sec_setting.reg_data[i] = *data_pos;
						data_pos++;
					}
					reg_sec_setting.reg_data_size = 7;
					write_len += 7;
				} else {
					if((length - write_len) == 0){
						pr_err("%s:%d firm write error\n", __func__, __LINE__);
					}
					memset(&reg_sec_setting, 0, sizeof(struct msm_camera_i2c_seq_reg_array));
					for(i=0;i<(length - write_len);i++){
						reg_sec_setting.reg_data[i] = *data_pos;
						data_pos++;
					}
					reg_sec_setting.reg_data_size = length - write_len;
					write_len += length - write_len;
				}
				

				rc = a_ctrl->i2c_client.i2c_func_tbl->
					i2c_write_seq_table(&a_ctrl->i2c_client,
					&conf_sec_array);

			}while(write_len < length);
			CDBG("%s write_len=%d length=%d\n", __func__, write_len, length);
			
		} else {
			uint16_t saddr = a_ctrl->i2c_client.client->addr >> 1;
			struct i2c_msg msg[] = {
				{
					.addr = saddr,
					.flags = 0,
				 },
			};

			msg[0].len = sizeof(bu63164gwl_act_init_fw_settings);
			msg[0].buf = bu63164gwl_act_init_fw_settings;
			rc = i2c_transfer(a_ctrl->i2c_client.client->adapter, msg, 1);
			if (rc < 0)
				CDBG("msm_camera_qup_i2c_txdata faild 0x%x\n", saddr);

			msg[0].len = sizeof(bu63164gwl_act_init_mem_settings);
			msg[0].buf = bu63164gwl_act_init_mem_settings;
			rc = i2c_transfer(a_ctrl->i2c_client.client->adapter, msg, 1);
			if (rc < 0)
				CDBG("msm_camera_qup_i2c_txdata faild 0x%x\n", saddr);


			conf_sec_array.addr_type = MSM_ACTUATOR_BYTE_ADDR;
			conf_sec_array.delay = 0;
			conf_sec_array.reg_setting = &reg_sec_setting;
			conf_sec_array.size = 1;
		}

		{
			uint16_t client_addr_type;
			uint16_t data;
			client_addr_type = a_ctrl->i2c_client.addr_type;
			a_ctrl->i2c_client.addr_type = MSM_CAMERA_I2C_WORD_ADDR;
			
			rc = a_ctrl->i2c_client.i2c_func_tbl->
				i2c_read(&a_ctrl->i2c_client,((BU63164GWL_OIS_CMD_MEM << 8) | 0xF6), &data,
				MSM_CAMERA_I2C_WORD_DATA);
			
			CDBG("%s FIRMVER=0x%0x\n", __func__, data);
			
			rc = a_ctrl->i2c_client.i2c_func_tbl->
				i2c_read(&a_ctrl->i2c_client,((BU63164GWL_OIS_CMD_MEM << 8) | 0x76), &data,
				MSM_CAMERA_I2C_WORD_DATA);
			
			CDBG("%s CEFTYPE=0x%0x\n", __func__, data);
			
			rc = a_ctrl->i2c_client.i2c_func_tbl->
				i2c_read(&a_ctrl->i2c_client,((BU63164GWL_OIS_CMD_MEM << 8) | 0xF7), &data,
				MSM_CAMERA_I2C_WORD_DATA);
			
			CDBG("%s OIS_STS=0x%0x\n", __func__, data);
			
			a_ctrl->i2c_client.addr_type = client_addr_type;

		}
		
		for(i = 0; i < ARRAY_SIZE(ois_init_setting1); i++) {
			rc = bu63164gwl_actuator_write_ois(a_ctrl, ois_init_setting1[i].type,
				ois_init_setting1[i].addr, ois_init_setting1[i].data);
			if (rc < 0){
				pr_err("msm_camera_i2c_txdata faild No.%d 0x%x\n", i, ois_init_setting1[i].data);
				return -EFAULT;
			}
		}

		msleep(30);

		for(i = 0; i < ARRAY_SIZE(ois_init_setting2); i++) {
			rc = bu63164gwl_actuator_write_ois(a_ctrl, ois_init_setting2[i].type,
				ois_init_setting2[i].addr, ois_init_setting2[i].data);
			if (rc < 0){
				pr_err("msm_camera_i2c_txdata faild No.%d 0x%x\n", i, ois_init_setting2[i].data);
				while(1){
					msleep(1000000);
				}
				return -EFAULT;
			}
		}
		a_ctrl->fw_inited = 1;
	}

	a_ctrl->i2c_data_type = set_info->actuator_params.i2c_data_type;
	a_ctrl->i2c_client.addr_type = set_info->actuator_params.i2c_addr_type;
	a_ctrl->reg_tbl_size = set_info->actuator_params.reg_tbl_size;
	if (a_ctrl->reg_tbl_size > MAX_ACTUATOR_REG_TBL_SIZE) {
		pr_err("MAX_ACTUATOR_REG_TBL_SIZE is exceeded.\n");
		return -EFAULT;
	}
	
	if( a_ctrl->i2c_reg_tbl != NULL ){
		kfree(a_ctrl->i2c_reg_tbl);
	}

	a_ctrl->i2c_reg_tbl =
		kmalloc(sizeof(struct msm_camera_i2c_reg_array) *
		(set_info->af_tuning_params.total_steps + 1), GFP_KERNEL);
	if (!a_ctrl->i2c_reg_tbl) {
		pr_err("kmalloc fail\n");
		return -ENOMEM;
	}

	if (copy_from_user(&a_ctrl->reg_tbl,
		(void *)set_info->actuator_params.reg_tbl_params,
		a_ctrl->reg_tbl_size *
		sizeof(struct msm_actuator_reg_params_t))) {
		kfree(a_ctrl->i2c_reg_tbl);
		a_ctrl->i2c_reg_tbl = NULL;
		return -EFAULT;
	}
	
	CDBG("a_ctrl->reg_tbl[0].reg_addr = %x", a_ctrl->reg_tbl[0].reg_addr );
	
	if (set_info->actuator_params.init_setting_size) {
		if (a_ctrl->func_tbl->actuator_init_focus) {
			init_settings = kmalloc(sizeof(struct reg_settings_t) *
				(set_info->actuator_params.init_setting_size),
				GFP_KERNEL);
			if (init_settings == NULL) {
				kfree(a_ctrl->i2c_reg_tbl);
				a_ctrl->i2c_reg_tbl = NULL;
				pr_err("Error allocating memory for init_settings\n");
				return -EFAULT;
			}
			if (copy_from_user(init_settings,
				(void *)set_info->actuator_params.init_settings,
				set_info->actuator_params.init_setting_size *
				sizeof(struct reg_settings_t))) {
				kfree(init_settings);
				kfree(a_ctrl->i2c_reg_tbl);
				a_ctrl->i2c_reg_tbl = NULL;
				pr_err("Error copying init_settings\n");
				return -EFAULT;
			}
			rc = a_ctrl->func_tbl->actuator_init_focus(a_ctrl,
				set_info->actuator_params.init_setting_size,
				a_ctrl->i2c_data_type,
				init_settings);
			kfree(init_settings);
			if (rc < 0) {
				kfree(a_ctrl->i2c_reg_tbl);
				a_ctrl->i2c_reg_tbl = NULL;
				pr_err("Error actuator_init_focus\n");
				return -EFAULT;
			}
		}
	}

	a_ctrl->initial_code = set_info->af_tuning_params.initial_code;
	if (a_ctrl->func_tbl->actuator_init_step_table)
		rc = a_ctrl->func_tbl->
			actuator_init_step_table(a_ctrl, set_info);

	a_ctrl->curr_step_pos = 0;
	a_ctrl->curr_region_index = 0;
	CDBG("Exit\n");

	return rc;
}


static int32_t bu63164gwl_act_i2c_write(struct msm_actuator_ctrl_t *a_ctrl,
	void __user *argp)
{
	struct msm_actuator_cfg_data *cdata = (struct msm_actuator_cfg_data *)argp;
	struct msm_camera_i2c_seq_reg_setting conf_sec_array;
	struct msm_camera_i2c_seq_reg_array reg_sec_setting;
	int32_t rc = -EFAULT;
	CDBG("Enter\n");
	
	if( cdata->cfg.i2c_info.length > I2C_SEQ_REG_DATA_MAX ){
		/* not support */
		pr_err("%s no support length %d failed\n", __func__, cdata->cfg.i2c_info.length);
		return -EFAULT;
	}
	
	memset(&reg_sec_setting, 0, sizeof(struct msm_camera_i2c_seq_reg_array));
	
	if(copy_from_user(
			(uint8_t*)reg_sec_setting.reg_data, 
			(uint8_t*)cdata->cfg.i2c_info.data,
			cdata->cfg.i2c_info.length)){
		pr_err("%s copy failed\n", __func__);
		return -EFAULT;
	}

#if 0
	{
		uint16_t client_addr_type;
		uint16_t data;
		client_addr_type = a_ctrl->i2c_client.addr_type;
		a_ctrl->i2c_client.addr_type = MSM_CAMERA_I2C_WORD_ADDR;
		
		rc = a_ctrl->i2c_client.i2c_func_tbl->
			i2c_read(&a_ctrl->i2c_client,((BU63164GWL_OIS_CMD_MEM << 8) | 0xF7), &data,
			MSM_CAMERA_I2C_WORD_DATA);
		
		CDBG("%s OIS_STS=0x%0x\n", __func__, data);
		
		a_ctrl->i2c_client.addr_type = client_addr_type;
	}
#endif

	conf_sec_array.addr_type = MSM_ACTUATOR_BYTE_ADDR;
	conf_sec_array.delay = 0;
	conf_sec_array.reg_setting = &reg_sec_setting;
	conf_sec_array.size = 1;

	reg_sec_setting.reg_addr = cdata->cfg.i2c_info.addr;

	reg_sec_setting.reg_data_size = cdata->cfg.i2c_info.length;

	CDBG("reg_sec_setting.reg_data[0]:0x%x, reg_sec_setting.reg_data[1]:0x%x\n", reg_sec_setting.reg_data[0], reg_sec_setting.reg_data[1]);
	CDBG("reg_sec_setting.reg_data[2]:0x%x, reg_sec_setting.reg_data[3]:0x%x\n", reg_sec_setting.reg_data[2], reg_sec_setting.reg_data[3]);
	rc = a_ctrl->i2c_client.i2c_func_tbl->
			i2c_write_seq_table(&a_ctrl->i2c_client,
			&conf_sec_array);
	CDBG("%s rc=%d\n", __func__, rc);
	if (rc < 0)
		return -EFAULT;

	CDBG("Exit\n");
	return rc;
}

static int32_t bu63164gwl_act_i2c_read(struct msm_actuator_ctrl_t *a_ctrl,
	void __user *argp)
{
	struct msm_actuator_cfg_data *cdata = (struct msm_actuator_cfg_data *)argp;
	int32_t rc = -EFAULT;
	uint16_t data;
	uint8_t out[2] ={ 0, 0 };
	uint16_t client_addr_type;

	CDBG("Enter\n");
	
	if( cdata->cfg.i2c_info.length > 2 ){
		/* not support */
		pr_err("%s no support length %d failed\n", __func__, cdata->cfg.i2c_info.length);
		return -EFAULT;
	}
	
	CDBG("%s i2c_info.addr = 0x%0x\n",   __func__, cdata->cfg.i2c_info.addr);
	CDBG("%s i2c_info.length = 0x%0x\n", __func__, cdata->cfg.i2c_info.length);
	
	client_addr_type = a_ctrl->i2c_client.addr_type;
	a_ctrl->i2c_client.addr_type = MSM_CAMERA_I2C_WORD_ADDR;
	
	rc = a_ctrl->i2c_client.i2c_func_tbl->
		i2c_read(&a_ctrl->i2c_client, cdata->cfg.i2c_info.addr, &data,
		MSM_CAMERA_I2C_WORD_DATA);
	
	CDBG("%s data=0x%0x\n", __func__, data);

	a_ctrl->i2c_client.addr_type = client_addr_type;
	out[0] = (data & 0xff00) >> 8;
	out[1] = data & 0x00ff;

	if (copy_to_user((uint8_t *)cdata->cfg.i2c_info.data,
		out,
		cdata->cfg.i2c_info.length)){
		pr_err("%s copy_to_user error\n",__func__);
		return -EFAULT;
	}
	
	CDBG("Exit\n");
	return rc;
}

static int32_t bu63164gwl_act_config(struct msm_actuator_ctrl_t *a_ctrl,
	void __user *argp)
{
	struct msm_actuator_cfg_data *cdata =
		(struct msm_actuator_cfg_data *)argp;
	int32_t rc = 0;
	mutex_lock(a_ctrl->actuator_mutex);
	CDBG("Enter\n");
	CDBG("%s type %d\n", __func__, cdata->cfgtype);
	switch (cdata->cfgtype) {
	case CFG_GET_ACTUATOR_INFO:
		cdata->is_af_supported = 1;
		cdata->cfg.cam_name = a_ctrl->cam_name;
		break;

	case CFG_SET_ACTUATOR_INFO:
		/* no reload */
		if( a_ctrl->step_position_table == NULL){
			rc = bu63164gwl_act_init(a_ctrl, &cdata->cfg.set_info);
		if (rc < 0)
			pr_err("init table failed %d\n", rc);
		}
		break;

	case CFG_SET_DEFAULT_FOCUS:
		rc = a_ctrl->func_tbl->actuator_set_default_focus(a_ctrl,
			&cdata->cfg.move);
		if (rc < 0)
			pr_err("move focus failed %d\n", rc);
		break;

	case CFG_MOVE_FOCUS:
		rc = a_ctrl->func_tbl->actuator_move_focus(a_ctrl,
			&cdata->cfg.move);
		if (rc < 0)
			pr_err("move focus failed %d\n", rc);
		break;
	
	case SHCFG_GET_I2C_DATA:
		rc = bu63164gwl_act_i2c_read(a_ctrl, argp);
		if (rc < 0)
			pr_err("get i2c failed %d\n", rc);
		break;
		
	case SHCFG_SET_I2C_DATA:
		rc = bu63164gwl_act_i2c_write(a_ctrl, argp);
		if (rc < 0)
			pr_err("set i2c failed %d\n", rc);
		break;
	
	default:
		break;
	}
	mutex_unlock(a_ctrl->actuator_mutex);
	CDBG("Exit\n");
	return rc;
}

static int32_t bu63164gwl_act_get_subdev_id(struct msm_actuator_ctrl_t *a_ctrl,
	void *arg)
{
	uint32_t *subdev_id = (uint32_t *)arg;
	CDBG("Enter\n");
	if (!subdev_id) {
		pr_err("failed\n");
		return -EINVAL;
	}
	if (a_ctrl->act_device_type == MSM_CAMERA_PLATFORM_DEVICE)
		*subdev_id = a_ctrl->pdev->id;
	else
		*subdev_id = a_ctrl->subdev_id;

	CDBG("subdev_id %d\n", *subdev_id);
	CDBG("Exit\n");
	return 0;
}

static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl = {
	.i2c_read = msm_camera_cci_i2c_read,
	.i2c_read_seq = msm_camera_cci_i2c_read_seq,
	.i2c_write = msm_camera_cci_i2c_write,
	.i2c_write_table = msm_camera_cci_i2c_write_table,
	.i2c_write_seq_table = msm_camera_cci_i2c_write_seq_table,
	.i2c_write_table_w_microdelay =
		msm_camera_cci_i2c_write_table_w_microdelay,
	.i2c_util = msm_sensor_cci_i2c_util,
};

static struct msm_camera_i2c_fn_t msm_sensor_qup_func_tbl = {
	.i2c_read = msm_camera_qup_i2c_read,
	.i2c_read_seq = msm_camera_qup_i2c_read_seq,
	.i2c_write = msm_camera_qup_i2c_write,
	.i2c_write_table = msm_camera_qup_i2c_write_table,
	.i2c_write_seq_table = msm_camera_qup_i2c_write_seq_table,
	.i2c_write_table_w_microdelay =
		msm_camera_qup_i2c_write_table_w_microdelay,
};

static int bu63164gwl_act_open(struct v4l2_subdev *sd,
	struct v4l2_subdev_fh *fh) {
	int rc = 0;
	struct msm_actuator_ctrl_t *a_ctrl =  v4l2_get_subdevdata(sd);
	CDBG("Enter\n");
	if (!a_ctrl) {
		pr_err("failed\n");
		return -EINVAL;
	}
	mutex_lock(a_ctrl->actuator_mutex);
	a_ctrl->cci_inited = 0;
	a_ctrl->num_instance++;
	mutex_unlock(a_ctrl->actuator_mutex);
	
#if 0 /* change the timing of init  */
	if (a_ctrl->act_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
		rc = a_ctrl->i2c_client.i2c_func_tbl->i2c_util(
			&a_ctrl->i2c_client, MSM_CCI_INIT);
		if (rc < 0)
			pr_err("cci_init failed\n");
	}
#endif

	a_ctrl->fw_inited = 0;
	
	CDBG("Exit\n");
	
	return rc;
}

static int bu63164gwl_act_close(struct v4l2_subdev *sd,
	struct v4l2_subdev_fh *fh) {
	int rc = 0;
	struct msm_actuator_ctrl_t *a_ctrl =  v4l2_get_subdevdata(sd);
	CDBG("Enter\n");
	if (!a_ctrl) {
		pr_err("failed\n");
		return -EINVAL;
	}
	mutex_lock(a_ctrl->actuator_mutex);
	a_ctrl->num_instance--;
	if( a_ctrl->num_instance < 0 )
		a_ctrl->num_instance = 0;
	
#ifdef ACTUATOR_DEBUG
	if( a_ctrl->num_instance == 0 )
#endif
	{
		bu63164gwl_act_power_down(a_ctrl);
	}
	
	mutex_unlock(a_ctrl->actuator_mutex);
	
	a_ctrl->fw_inited = 0;
	
	CDBG("Exit\n");
	return rc;
}

static const struct v4l2_subdev_internal_ops bu63164gwl_act_internal_ops = {
	.open = bu63164gwl_act_open,
	.close = bu63164gwl_act_close,
};

static long bu63164gwl_act_subdev_ioctl(struct v4l2_subdev *sd,
			unsigned int cmd, void *arg)
{
	struct msm_actuator_ctrl_t *a_ctrl = v4l2_get_subdevdata(sd);
	void __user *argp = (void __user *)arg;
	CDBG("Enter\n");
	CDBG("%s:%d a_ctrl %p argp %p cmd %x\n", __func__, __LINE__, a_ctrl, argp, cmd);
	switch (cmd) {
	case VIDIOC_MSM_SENSOR_GET_SUBDEV_ID:
		return bu63164gwl_act_get_subdev_id(a_ctrl, argp);
	case VIDIOC_MSM_ACTUATOR_CFG:
		return bu63164gwl_act_config(a_ctrl, argp);
	case MSM_SD_SHUTDOWN:
		bu63164gwl_act_close(sd, NULL);
		return 0;
	default:
		return -ENOIOCTLCMD;
	}
}

static int32_t bu63164gwl_act_power_up(struct msm_actuator_ctrl_t *a_ctrl)
{
	int rc = 0;
	
	CDBG("%s called\n", __func__);

#if 0
	CDBG("vcm info: %x %x\n", a_ctrl->vcm_pwd,
		a_ctrl->vcm_enable);
	if (a_ctrl->vcm_enable) {
		rc = gpio_request(a_ctrl->vcm_pwd, "msm_actuator");
		if (!rc) {
			CDBG("Enable VCM PWD\n");
			gpio_direction_output(a_ctrl->vcm_pwd, 1);
		}
	}
#endif
	CDBG("Exit\n");
	return rc;
}

static int32_t bu63164gwl_act_power(struct v4l2_subdev *sd, int on)
{
	int rc = 0;
	struct msm_actuator_ctrl_t *a_ctrl = v4l2_get_subdevdata(sd);
	CDBG("Enter\n");
	mutex_lock(a_ctrl->actuator_mutex);
	if (on)
		rc = bu63164gwl_act_power_up(a_ctrl);
	else
		rc = bu63164gwl_act_power_down(a_ctrl);
	mutex_unlock(a_ctrl->actuator_mutex);
	CDBG("Exit\n");
	return rc;
}

static struct v4l2_subdev_core_ops bu63164gwl_act_subdev_core_ops = {
	.ioctl = bu63164gwl_act_subdev_ioctl,
	.s_power = bu63164gwl_act_power,  /* not called in normal power on/off sequence */
};

static struct v4l2_subdev_ops bu63164gwl_act_subdev_ops = {
	.core = &bu63164gwl_act_subdev_core_ops,
};

static const struct i2c_device_id bu63164gwl_act_i2c_id[] = {
	{"bu63164gwl,actuator", (kernel_ulong_t)NULL},
	{ }
};

static int32_t bu63164gwl_act_i2c_probe(struct i2c_client *client,
	const struct i2c_device_id *id)
{
	int rc = 0;
	struct msm_actuator_ctrl_t *act_ctrl_t = NULL;
	CDBG("Enter\n");

	if (client == NULL) {
		pr_err("bu63164gwl_act_i2c_probe: client is null\n");
		rc = -EINVAL;
		goto probe_failure;
	}

	act_ctrl_t = kzalloc(sizeof(struct msm_actuator_ctrl_t),
		GFP_KERNEL);
	if (!act_ctrl_t) {
		pr_err("%s:%d failed no memory\n", __func__, __LINE__);
		return -ENOMEM;
	}

	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
		pr_err("i2c_check_functionality failed\n");
		goto probe_failure;
	}

	CDBG("client = %x\n", (unsigned int) client);

	rc = of_property_read_u32(client->dev.of_node, "cell-index",
		&act_ctrl_t->subdev_id);
	CDBG("cell-index %d, rc %d\n", act_ctrl_t->subdev_id, rc);
	if (rc < 0) {
		pr_err("failed rc %d\n", rc);
		return rc;
	}

	act_ctrl_t->i2c_driver = &bu63164gwl_act_i2c_driver;
	act_ctrl_t->i2c_client.client = client;
	act_ctrl_t->curr_step_pos = 0,
	act_ctrl_t->curr_region_index = 0,
	/* Set device type as I2C */
	act_ctrl_t->act_device_type = MSM_CAMERA_I2C_DEVICE;
	act_ctrl_t->i2c_client.i2c_func_tbl = &msm_sensor_qup_func_tbl;
	act_ctrl_t->act_v4l2_subdev_ops = &bu63164gwl_act_subdev_ops;
	act_ctrl_t->actuator_mutex = &bu63164gwl_act_mutex;

	act_ctrl_t->cam_name = act_ctrl_t->subdev_id;
	CDBG("act_ctrl_t->cam_name: %d", act_ctrl_t->cam_name);
	/* Assign name for sub device */
	snprintf(act_ctrl_t->msm_sd.sd.name, sizeof(act_ctrl_t->msm_sd.sd.name),
		"%s", act_ctrl_t->i2c_driver->driver.name);

	/* Initialize sub device */
	v4l2_i2c_subdev_init(&act_ctrl_t->msm_sd.sd,
		act_ctrl_t->i2c_client.client,
		act_ctrl_t->act_v4l2_subdev_ops);
	v4l2_set_subdevdata(&act_ctrl_t->msm_sd.sd, act_ctrl_t);
	act_ctrl_t->msm_sd.sd.internal_ops = &bu63164gwl_act_internal_ops;
	act_ctrl_t->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
	media_entity_init(&act_ctrl_t->msm_sd.sd.entity, 0, NULL, 0);
	act_ctrl_t->msm_sd.sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV;
	act_ctrl_t->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_ACTUATOR;
	act_ctrl_t->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x2;
	msm_sd_register(&act_ctrl_t->msm_sd);
#if 1
	act_ctrl_t->num_instance = 0;
	act_ctrl_t->cci_inited   = 0;
	act_ctrl_t->fw_inited = 0;
#endif

	pr_info("bu63164gwl_act_i2c_probe: succeeded\n");
	CDBG("Exit\n");

probe_failure:
	return rc;
}

static int32_t bu63164gwl_act_platform_probe(struct platform_device *pdev)
{
	int32_t rc = 0;
	struct msm_camera_cci_client *cci_client = NULL;
	struct msm_actuator_ctrl_t *msm_actuator_t = NULL;
	CDBG("Enter\n");

	if (!pdev->dev.of_node) {
		pr_err("of_node NULL\n");
		return -EINVAL;
	}

	msm_actuator_t = kzalloc(sizeof(struct msm_actuator_ctrl_t),
		GFP_KERNEL);
	if (!msm_actuator_t) {
		pr_err("%s:%d failed no memory\n", __func__, __LINE__);
		return -ENOMEM;
	}
	rc = of_property_read_u32((&pdev->dev)->of_node, "cell-index",
		&pdev->id);
	CDBG("cell-index %d, rc %d\n", pdev->id, rc);
	if (rc < 0) {
		pr_err("failed rc %d\n", rc);
		return rc;
	}

	rc = of_property_read_u32((&pdev->dev)->of_node, "qcom,cci-master",
		&msm_actuator_t->cci_master);
	CDBG("qcom,cci-master %d, rc %d\n", msm_actuator_t->cci_master, rc);
	if (rc < 0) {
		pr_err("failed rc %d\n", rc);
		return rc;
	}

	msm_actuator_t->act_v4l2_subdev_ops = &bu63164gwl_act_subdev_ops;
	msm_actuator_t->actuator_mutex = &bu63164gwl_act_mutex;
	msm_actuator_t->cam_name = pdev->id;

	/* Set platform device handle */
	msm_actuator_t->pdev = pdev;
	/* Set device type as platform device */
	msm_actuator_t->act_device_type = MSM_CAMERA_PLATFORM_DEVICE;
	msm_actuator_t->i2c_client.i2c_func_tbl = &msm_sensor_cci_func_tbl;
	msm_actuator_t->i2c_client.cci_client = kzalloc(sizeof(
		struct msm_camera_cci_client), GFP_KERNEL);
	if (!msm_actuator_t->i2c_client.cci_client) {
		pr_err("failed no memory\n");
		return -ENOMEM;
	}

	cci_client = msm_actuator_t->i2c_client.cci_client;
	cci_client->cci_subdev = msm_cci_get_subdev();
	v4l2_subdev_init(&msm_actuator_t->msm_sd.sd,
		msm_actuator_t->act_v4l2_subdev_ops);
	v4l2_set_subdevdata(&msm_actuator_t->msm_sd.sd, msm_actuator_t);
	msm_actuator_t->msm_sd.sd.internal_ops = &bu63164gwl_act_internal_ops;
	msm_actuator_t->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
	snprintf(msm_actuator_t->msm_sd.sd.name,
		ARRAY_SIZE(msm_actuator_t->msm_sd.sd.name), "bu63164gwl_act");
	media_entity_init(&msm_actuator_t->msm_sd.sd.entity, 0, NULL, 0);
	msm_actuator_t->msm_sd.sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV;
	msm_actuator_t->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_ACTUATOR;
	msm_actuator_t->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x2;
	msm_sd_register(&msm_actuator_t->msm_sd);
#if 1
	msm_actuator_t->num_instance = 0;
	msm_actuator_t->cci_inited   = 0;
	msm_actuator_t->fw_inited = 0;
#endif
	
	
	CDBG("Exit\n");
	return rc;
}

static const struct of_device_id bu63164gwl_act_i2c_dt_match[] = {
	{.compatible = "bu63164gwl,actuator"},
	{}
};

MODULE_DEVICE_TABLE(of, bu63164gwl_act_i2c_dt_match);

static struct i2c_driver bu63164gwl_act_i2c_driver = {
	.id_table = bu63164gwl_act_i2c_id,
	.probe  = bu63164gwl_act_i2c_probe,
	.remove = __exit_p(bu63164gwl_act_i2c_remove),
	.driver = {
		.name = "bu63164gwl,actuator",
		.owner = THIS_MODULE,
		.of_match_table = bu63164gwl_act_i2c_dt_match,
	},
};

static const struct of_device_id bu63164gwl_act_dt_match[] = {
	{.compatible = "bu63164gwl,actuator", .data = NULL},
	{}
};

MODULE_DEVICE_TABLE(of, bu63164gwl_act_dt_match);

static struct platform_driver bu63164gwl_act_platform_driver = {
	.driver = {
		.name = "bu63164gwl,actuator",
		.owner = THIS_MODULE,
		.of_match_table = bu63164gwl_act_dt_match,
	},
};

static int __init bu63164gwl_act_init_module(void)
{
	int32_t rc = 0;
#if defined(CONFIG_MACH_LYNX_DL60)
	uint16_t rev = 0;
#endif
	CDBG("Enter\n");

#if defined(CONFIG_MACH_LYNX_DL60)
	rev = sh_boot_get_hw_revision();
	
	CDBG("%s rev=0x%0x\n", __func__, rev);
	if(rev == 0x00){
		rc = platform_driver_probe(&bu63164gwl_act_platform_driver,
			bu63164gwl_act_platform_probe);
		CDBG("%s:%d rc %d\n", __func__, __LINE__, rc);
		return rc;
	} else {
		rc = i2c_add_driver(&bu63164gwl_act_i2c_driver);
		CDBG("%s:%d rc %d\n", __func__, __LINE__, rc);
		return rc;
	}
#else
	rc = platform_driver_probe(&bu63164gwl_act_platform_driver,
		bu63164gwl_act_platform_probe);
	if (!rc)
		return rc;
	CDBG("%s:%d rc %d\n", __func__, __LINE__, rc);
	return i2c_add_driver(&bu63164gwl_act_i2c_driver);
#endif
}

static struct msm_actuator bu63164gwl_act_table = {
	.act_type = ACTUATOR_VCM,
	.func_tbl = {
		.actuator_init_step_table = bu63164gwl_act_init_step_table,
		.actuator_move_focus = bu63164gwl_act_move_focus,
		.actuator_write_focus = bu63164gwl_act_write_focus,
		.actuator_set_default_focus = bu63164gwl_act_set_default_focus,
		.actuator_init_focus = bu63164gwl_act_init_focus,
		.actuator_parse_i2c_params = bu63164gwl_act_parse_i2c_params,
	},
};

module_init(bu63164gwl_act_init_module);
MODULE_DESCRIPTION("bu63164gwl ACTUATOR");
MODULE_LICENSE("GPL v2");
